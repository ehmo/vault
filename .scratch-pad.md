# Scratch Pad — Continual Learning Log

## Session Log

### Session 1 — UX Design Audit Implementation (Feb 8, 2026)
- **Query**: Implement 11-workstream UX design audit plan (WS1-WS11) across the Vaultaire iOS app
- **Approach**: Sequential workstream implementation with build verification and git commit after each
- **Errors**:
  - `.foregroundStyle(.accentColor)` fails — `ShapeStyle` has no member `accentColor`. Fix: use `Color.accentColor`
  - `bd update ○` failed — passed status indicator character instead of issue ID. Fix: use `bd list` to get actual ID
- **Corrections**: None from user — autonomous implementation
- **Key Learnings**:
  - Codable optionals (`Date?`) provide backward compat for existing vault indexes without migration
  - When adding files to pbxproj manually, use `UX` prefix IDs for UX-related additions (consistent with `LA`, `SE` prefixes)
  - `SubscriptionManager.maxFreeFilesPerVault` is a static constant (100) — reference directly, don't duplicate the value
  - Date grouping with photo viewer requires computing global index across all sorted images, not per-group index

### Session 2 — Share Upload Failure Fix (Feb 8, 2026)
- **Query**: Vault share fails with "shared vault couldn't be completed" after CloudKit upload starts
- **Approach**: Traced upload flow through ShareVaultView → BackgroundShareTransferManager → CloudKitSharingManager. Identified two root causes.
- **Root Causes**:
  - No `UIApplication.beginBackgroundTask()` — iOS suspends app when user dismisses share sheet, killing the in-flight CloudKit upload. Telemetry showed only 3 Live Activity ticks (~0.5s) before silence = classic iOS suspension.
  - No retry on transient CKErrors — a single network hiccup on any of 9 sequential chunk saves causes immediate failure.
- **Fix**: Added `beginBackgroundTask`/`endBackgroundTask` wrapping both upload and import `Task.detached` closures. Added `saveWithRetry()` with 3 retries + exponential backoff for transient CKErrors (networkFailure, serviceUnavailable, zoneBusy, requestRateLimited).
- **Key Learnings**:
  - `Task.detached` does NOT get background execution time — iOS can suspend it immediately when app backgrounds
  - `CKDatabase.save()` convenience API has no QoS/timeout config — for production use, consider `CKModifyRecordsOperation`
  - `CKError.retryAfterSeconds` provides server-suggested retry delay — always respect it before falling back to exponential backoff
  - The upload flow: BackgroundShareTransferManager orchestrates (re-encrypt files → plist encode → CloudKitSharingManager uploads chunks sequentially → saves manifest)

### Session 3 — Incremental Sync for Shared Vaults (Feb 9, 2026)
- **Query**: Implement SVDF v4 incremental sync — adding 1 file to shared vault was re-encrypting and re-uploading ALL files
- **Approach**: 4-layer optimization: (1) append-stable binary format (SVDFSerializer), (2) per-share encrypted file cache (ShareSyncCache), (3) chunk-hash diffing in CloudKit upload, (4) recipient delta import
- **Files created**: SVDFSerializer.swift, ShareSyncCache.swift
- **Files modified**: ShareSyncManager.swift (replaced full rebuild with incremental), CloudKitSharingManager.swift (added syncSharedVaultIncremental), BackgroundShareTransferManager.swift (SVDF v4 for initial upload + cache init), VaultView.swift (delta import for SVDF, legacy fallback for v1-v3), VaultStorage.swift (syncSequence on ShareRecord)
- **Errors**: None — first-attempt build success
- **Key Learnings**:
  - Duplicate simulator names cause `xcodebuild` ambiguity — use `-destination 'platform=iOS Simulator,id=<UUID>'` instead of `name=`
  - Sharing group in pbxproj uses `014000xxx` prefix IDs
  - VaultFileEntry has optional `filename`, `mimeType`, `createdAt` — always provide fallback values when building SharedFile from entries
  - Binary format with little-endian encoding requires careful cursor tracking; `Data.readUInt32(at:)` helpers avoid raw pointer arithmetic
  - CloudKit deterministic record IDs (`{shareVaultId}_chunk_{index}`) allow update-in-place without delete+create

---

## Error Tracker

- **ShapeStyle vs Color**: `.foregroundStyle(.accentColor)` doesn't compile — `accentColor` is on `Color`, not `ShapeStyle`. Always use `Color.accentColor` or `.tint(.accentColor)`.
- **Beads ID parsing**: `bd` commands need the actual issue ID (e.g., `VAULT-5vs`), not display characters. Always run `bd list` first if unsure.
- **SourceKit false positives**: Cross-file SourceKit diagnostics ("Cannot find X in scope") are common in this project and don't represent real build errors. Trust `xcodebuild` results over editor diagnostics.
- **Task.detached + backgrounding = suspension**: iOS will suspend `Task.detached` closures when the app backgrounds. Any long-running work (CloudKit uploads, network calls) MUST be wrapped in `beginBackgroundTask`/`endBackgroundTask`.
- **No retry on CloudKit saves**: `CKDatabase.save()` has no built-in retry. Transient errors (network hiccups, rate limits) cause immediate failure. Always wrap in retry logic.
- **CKRecord INSERT vs UPDATE**: `CKRecord(recordType:recordID:)` creates a NEW record object. `save()` on it attempts INSERT, failing with `serverRecordChanged` (code 14) if record exists. To UPDATE, must FETCH the existing record first via `publicDatabase.record(for:)`, modify its fields, then save. This is critical for incremental chunk updates.
- **Initial upload → sync cache gap**: `uploadSharedVault()` creates chunks in CloudKit but doesn't initialize `ShareSyncCache`. First `syncSharedVaultIncremental()` call sees empty `previousChunkHashes` → tries INSERT on all existing chunks → CKError 14. Prevention: always fetch-or-create before save.
- **deinit + [weak self] = crash**: `[weak self]` in closures dispatched from `deinit` causes "Cannot form weak reference to instance in process of deallocation". Prevention: capture specific properties by value, not `self`.
- **SwiftUI animation leak in ZStack**: `.animation(_:value:)` on one child in a ZStack can affect siblings. Prevention: isolate animated elements in separate overlays.
- **Background task async endBackgroundTask**: `Task { @MainActor in UIApplication.shared.endBackgroundTask(id) }` inside `defer` may never execute when the app is being suspended. Prevention: use `MainActor.assumeIsolated` in the expiration handler to call `endBackgroundTask` synchronously. Store `bgTaskId` as a property with an idempotent `endBackgroundExecution()` helper.
- **Orphaned background task IDs**: Calling `beginBackgroundTask` multiple times without ending old ones leaks task IDs. Prevention: always call `endBackgroundExecution()` before `beginBackgroundTask`, and store only one `currentBgTaskId`.
- **UI only showing happy-path status**: Showing UI only for `.uploading` but not `.uploadFailed`/`.uploadComplete` means the user sees nothing when things fail. Prevention: always handle ALL non-idle enum cases in status UI.

---

## Corrections and Preferences

- **Commit frequency**: User prefers commit + push after every successful build. Don't accumulate changes.
- **Beads tracking**: Use beads for multi-session work, TodoWrite for single-session tasks.
- **Plan mode**: Make plans extremely concise. Sacrifice grammar for brevity.
- **Subagent model**: Always use opus model for subagents.

---

## Anticipated Improvements

- Always wrap `Color.accentColor` (not bare `.accentColor`) in `.foregroundStyle()` calls
- Run `bd list` before closing issues to confirm IDs exist
- When adding optional fields to Codable structs, always provide default `nil` in init for backward compat
- When modifying grid views that feed into a full-screen viewer, verify the index mapping is global not local
- When writing CloudKit save operations with deterministic record IDs, ALWAYS use fetch-or-create pattern — never assume a record doesn't exist
- When there's an initial upload path AND a sync path for the same CloudKit records, verify the sync cache is properly seeded after initial upload
- Never use `[weak self]` in `deinit` — capture properties by value instead
- When using animated floating buttons (FAB), separate the button into its own overlay to prevent animation interference from siblings
- When using `beginBackgroundTask`, always: (1) store the ID as a property, (2) end synchronously in the expiration handler via `MainActor.assumeIsolated`, (3) end any prior task before creating a new one
- When displaying transfer/upload/sync status, always handle ALL enum cases (uploading, failed, complete, etc.) — never just the happy path

### Session 4 — Fan Menu UX + CloudKit Chunk Overlap Fix (Feb 9, 2026)
- **Query**: Fix fan menu button positioning/vanishing, fix CloudKit CKError 14 "record to insert already exists" during multi-recipient share sync
- **Approach**:
  1. Fan menu: separated + button into own overlay to isolate animation context, added `.buttonStyle(.plain)` to prevent press dimming
  2. CloudKit: always fetch existing record before save (fetch-or-create pattern), handle code 14 in saveWithRetry as defense-in-depth
  3. CameraManager: fix deinit crash from weak self in async dispatch during deallocation
- **Root Causes**:
  - **Fan menu vanish**: Default ButtonStyle opacity dimming on press + `.animation` modifier leaking across ZStack siblings
  - **CKError 14**: Initial upload (`uploadSharedVault()`) creates chunks in CloudKit but never populates `ShareSyncCache`. First incremental sync reads empty `previousChunkHashes`, treats ALL chunks as new, tries INSERT on records that already exist
  - **CameraManager crash**: `deinit` called `stopSession()` which uses `[weak self]` — can't form weak ref to deallocating object
- **Key Learnings**:
  - SwiftUI `.animation(_:value:)` can leak to sibling views in same ZStack — separate into distinct overlays for isolation
  - CKRecord.save() treats new CKRecord objects as INSERT, fetched objects as UPDATE — critical distinction
  - Initial upload → incremental sync handoff has a cache gap — always defend against missing/stale cache state
  - Never use `[weak self]` in `deinit` closures — capture specific properties instead

### Session 5 — Background Task Expiration + Upload Progress Visibility (Feb 10, 2026)
- **Query**: Fix iOS background task expiration during large vault uploads; add upload status visibility to Share Vault management screen
- **Approach**:
  1. Background task: Store `currentBgTaskId` as property, use `MainActor.assumeIsolated` in expiration handler for synchronous cleanup, add `endBackgroundExecution()` idempotent helper
  2. Upload progress: Replace narrow `.uploading`-only check with `transferStatusBanner` showing `.uploading`, `.uploadFailed`, `.uploadComplete` states
  3. Added missing `beginBackgroundTask` to `startBackgroundImport`
- **Root Causes**:
  - **Background task not ended**: Expiration handler dispatched `cancel()` via `Task { @MainActor in }` — async hop may not execute before iOS suspends. `endBackgroundTask` must be called synchronously in the handler.
  - **No upload status shown**: ShareVaultView only showed progress for `.uploading` enum case. `.uploadFailed` and `.uploadComplete` had no UI — user saw nothing when upload failed.
  - **Missing background task**: `startBackgroundImport` had no `beginBackgroundTask` at all — iOS could suspend during import.
- **Key Learnings**:
  - `UIApplication.beginBackgroundTask` expiration handler runs on main queue — use `MainActor.assumeIsolated` for synchronous @MainActor access without async hop
  - Must call `endBackgroundTask` before expiration handler returns, not via async dispatch
  - Multiple `beginBackgroundTask` calls without matching `endBackgroundTask` = orphaned task IDs
  - Always show ALL non-idle transfer states in UI, not just the "happy path" uploading state

---

## Cumulative Learnings

- **Session count**: 5
- **Build success rate**: 18/18 (Session 5: 1/1 first-attempt)
- **Key pattern**: Sequential workstream implementation with build gates works well for large multi-file UX changes
- **Architecture insight**: This codebase uses a 3-tier file model (VaultFileItem → LightweightFileEntry → VaultFileEntry) — changes to file metadata must propagate through all three
- **Sharing architecture**: BackgroundShareTransferManager (@MainActor, @Observable) → Task.detached for crypto work → CloudKitSharingManager for CloudKit ops. All crypto keys captured by value to survive vault lock.
- **Incremental sync**: SVDF v4 is append-stable (existing bytes never move). ShareSyncCache stores per-share encrypted files + SVDF blob + chunk hashes. Sync flow: diff file IDs → re-encrypt only new files (check cache first) → build SVDF incrementally → hash chunks → upload only changed chunks.
- **CloudKit idempotency**: ALWAYS fetch before save for deterministic record IDs. Never trust local cache to know whether a CloudKit record exists — the initial upload path, partial failures, and retries can all leave records that the cache doesn't know about. Use `fetchOrCreateRecord()` pattern everywhere.
