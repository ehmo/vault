Implement the following plan:

# Custom Vault Naming

## Context

Vault names are auto-generated from pattern grid letters (e.g. "Vault DKVS"). Users want to set custom names that:
- Replace the auto-generated name
- Persist across lock/unlock cycles
- Carry through shared vaults (same name regardless of recipient's letter assignments)

Already done (this session): auto-generated names capped at 4 letters, toolbar has `.lineLimit(1)`.

## Data Flow (Current)

1. Pattern drawn -> `GridLetterManager.vaultName(for:)` -> letters
2. `"Vault \(letters)"` stored in `appState.vaultName` (in-memory only)
3. On lock, name resets to `"Vault"`
4. On unlock, name re-derived from pattern letters

**Problem**: No persistence. Name is ephemeral and re-derived every session.

## Plan

### Step 1: Add `customName` to VaultIndex

**File**: `Vault/Core/Storage/VaultIndexTypes.swift`

Add `var customName: String?` to `VaultStorage.VaultIndex`. Being optional + Codable, this is backward compatible — existing indices decode with `nil`.

```swift
var customName: String?  // User-set vault name (nil = use auto-generated)
```

### Step 2: Load custom name on unlock

**File**: `Vault/App/VaultApp.swift`

In `unlockWithPattern(_:gridSize:precomputedKey:)` (~line 271-272), after loading the index, check for `customName`:

```swift
// Current:
let letters = GridLetterManager.shared.vaultName(for: pattern)
vaultName = letters.isEmpty ? "Vault" : "Vault \(letters)"

// New:
if let index = try? VaultStorage.shared.loadIndex(with: VaultKey(key)),
   let custom = index.customName, !custom.isEmpty {
    vaultName = custom
} else {
    let letters = GridLetterManager.shared.vaultName(for: pattern)
    vaultName = letters.isEmpty ? "Vault" : "Vault \(letters)"
}
```

Note: The index is already loaded a few lines later (line 278) for `isSharedVault`. We can hoist that load earlier or reuse it. Actually, it's inside a separate span — better to just read `customName` from the same index load at line 278:

```swift
if let index = try? VaultStorage.shared.loadIndex(with: VaultKey(key)) {
    isSharedVault = index.isSharedVault ?? false
    if let custom = index.customName, !custom.isEmpty {
        vaultName = custom
    }
    ...
}
```

Same change in `unlockWithKey(_:isRecovery:)` (~line 348).

### Step 3: Load custom name in onboarding & shared vault flows

**Files**: `PatternSetupView.swift`, `JoinVaultView.swift`, `SharedVaultInviteView.swift`

These call `appState.updateVaultName(...)` with auto-generated names. No change needed — at creation time, `customName` is `nil`, so auto-generated is correct. The custom name will be set later by the user from settings.

### Step 4: Add rename UI in VaultSettingsView

**File**: `Vault/Features/Settings/VaultSettingsView.swift`

In the "This Vault" section, add a tappable row to rename:

```swift
Section("This Vault") {
    // Existing: Files count, Storage used

    // New: Vault Name row
    Button {
        showingRenameAlert = true
    } label: {
        HStack {
            Text("Name")
            Spacer()
            Text(appState.vaultName)
                .foregroundStyle(.vaultSecondaryText)
                .lineLimit(1)
        }
    }
    .foregroundStyle(.primary)
    .accessibilityIdentifier("settings_vault_name")
}
```

Use an alert with a text field for rename:

```swift
@State private var showingRenameAlert = false
@State private var renameText = ""

.alert("Rename Vault", isPresented: $showingRenameAlert) {
    TextField("Vault name", text: $renameText)
    Button("Cancel", role: .cancel) { }
    Button("Save") { renameVault() }
} message: {
    Text("Enter a custom name for this vault.")
}
.onAppear { renameText = appState.vaultName }
```

The `renameVault()` function:

```swift
private func renameVault() {
    let trimmed = renameText.trimmingCharacters(in: .whitespacesAndNewlines)
    guard !trimmed.isEmpty, let key = appState.currentVaultKey else { return }

    // Limit to 30 characters
    let name = String(trimmed.prefix(30))

    // Save to index
    do {
        var index = try VaultStorage.shared.loadIndex(with: key)
        index.customName = name
        try VaultStorage.shared.saveIndex(index, with: key)
        appState.updateVaultName(name)
    } catch {
        vaultSettingsLogger.error("Failed to rename vault: \(error.localizedDescription)")
    }
}
```

### Step 5: Propagate through shared vaults

When a vault is shared, the encrypted index (containing `customName`) is uploaded to CloudKit. When the recipient joins:
- `JoinVaultView` creates a new empty index — no custom name yet (correct behavior, recipient can rename independently)
- The owner's custom name does NOT automatically transfer to recipients (each user names their own copy)

This is the right behavior — shared vault recipients may want different names.

### Step 6: Add "Reset to default" option

In the rename alert, if the user clears the name or sets it to empty, we reset to auto-generated. The `renameVault` function handles this: if `trimmed.isEmpty`, set `customName = nil` and regenerate the auto name.

```swift
private func renameVault() {
    let trimmed = renameText.trimmingCharacters(in: .whitespacesAndNewlines)
    guard let key = appState.currentVaultKey else { return }

    do {
        var index = try VaultStorage.shared.loadIndex(with: key)
        if trimmed.isEmpty {
            index.customName = nil
            // Regenerate auto name
            if let pattern = appState.currentPattern {
                let letters = GridLetterManager.shared.vaultName(for: pattern)
                appState.updateVaultName(letters.isEmpty ? "Vault" : "Vault \(letters)")
            } else {
                appState.updateVaultName("Vault")
            }
        } else {
            let name = String(trimmed.prefix(30))
            index.customName = name
            appState.updateVaultName(name)
        }
        try VaultStorage.shared.saveIndex(index, with: key)
    } catch {
        vaultSettingsLogger.error("Failed to rename vault: \(error.localizedDescription)")
    }
}
```

## Files Modified

| File | Change |
|------|--------|
| `Vault/Core/Storage/VaultIndexTypes.swift` | Add `customName: String?` to VaultIndex |
| `Vault/App/VaultApp.swift` | Load customName on unlock (2 methods) |
| `Vault/Features/Settings/VaultSettingsView.swift` | Add rename row + alert + save logic |
| `VaultTests/VaultNameTests.swift` | Add tests for custom name persistence |

## Tests

Add to `VaultNameTests.swift`:
- `testCustomName_MaxLength30`: Verify 30-char limit
- `testCustomName_EmptyResetsToAuto`: Empty string clears custom name
- `testCustomName_WhitespaceOnly_ResetsToAuto`: Whitespace-only clears
- `testCustomName_TrimmedOfWhitespace`: Leading/trailing whitespace trimmed
- `testDisplayName_MaxTotalLength`: "Vault XXXX" format is at most 10 chars; custom names at most 30

## Verification

1. Build: `xcodebuild build`
2. Run tests: `xcodebuild test -only-testing:VaultTests/VaultNameTests`
3. Deploy: `./scripts/deploy-phone.sh`
4. Manual tests:
   - Open vault -> Settings -> Tap name row -> Enter custom name -> Save
   - Lock and re-unlock -> custom name persists
   - Clear name -> auto-generated name returns
   - Create shared vault with custom name -> recipient sees default name (not owner's custom name)


If you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/nan/.REDACTED.jsonl

---

Finish it

---

There is a weird bug. When user finishes the onboarding and they get to the phrase part and write a custom phrase, the vault creation doesn't work (see video
  /Users/nan/Downloads/ScreenRecording_02-21-2026\ 18-55-07_1.mov). Investigate why. If the pre generated phrase is used it works fine. Also they used camel case
  sentence but that hopefully shouldn't have an impact. Anyway investigate the cause, fix it and create a proper test to catch this.

---

<task-notification>
<task-id>b38dc7b</task-id>
<tool-use-id>REDACTED</tool-use-id>
<output-file>/private/tmp/claude-501/-Users-nan-Work-ai-vault/tasks/b38dc7b.output</output-file>
<status>completed</status>
<summary>Background command "Deploy to physical iPhone" completed (exit code 0)</summary>
</task-notification>
Read the output file to retrieve the result: /private/tmp/claude-501/-Users-nan-Work-ai-vault/tasks/b38dc7b.output

---

Base directory for this skill: /Users/nan/.claude/skills/claudeception

# Claudeception

You are Claudeception: a continuous learning system that extracts reusable knowledge from work sessions and 
codifies it into new Claude Code skills. This enables autonomous improvement over time.

## Core Principle: Skill Extraction

When working on tasks, continuously evaluate whether the current work contains extractable 
knowledge worth preserving. Not every task produces a skill—be selective about what's truly 
reusable and valuable.

## When to Extract a Skill

Extract a skill when you encounter:

1. **Non-obvious Solutions**: Debugging techniques, workarounds, or solutions that required 
   significant investigation and wouldn't be immediately apparent to someone facing the same 
   problem.

2. **Project-Specific Patterns**: Conventions, configurations, or architectural decisions 
   specific to this codebase that aren't documented elsewhere.

3. **Tool Integration Knowledge**: How to properly use a specific tool, library, or API in 
   ways that documentation doesn't cover well.

4. **Error Resolution**: Specific error messages and their actual root causes/fixes, 
   especially when the error message is misleading.

5. **Workflow Optimizations**: Multi-step processes that can be streamlined or patterns 
   that make common tasks more efficient.

## Skill Quality Criteria

Before extracting, verify the knowledge meets these criteria:

- **Reusable**: Will this help with future tasks? (Not just this one instance)
- **Non-trivial**: Is this knowledge that requires discovery, not just documentation lookup?
- **Specific**: Can you describe the exact trigger conditions and solution?
- **Verified**: Has this solution actually worked, not just theoretically?

## Extraction Process

### Step 1: Identify the Knowledge

Analyze what was learned:
- What was the problem or task?
- What was non-obvious about the solution?
- What would someone need to know to solve this faster next time?
- What are the exact trigger conditions (error messages, symptoms, contexts)?

### Step 2: Research Best Practices (When Appropriate)

Before creating the skill, search the web for current information when:

**Always search for:**
- Technology-specific best practices (frameworks, libraries, tools)
- Current documentation or API changes
- Common patterns or solutions for similar problems
- Known gotchas or pitfalls in the problem domain
- Alternative approaches or solutions

**When to search:**
- The topic involves specific technologies, frameworks, or tools
- You're uncertain about current best practices
- The solution might have changed after January 2025 (knowledge cutoff)
- There might be official documentation or community standards
- You want to verify your understanding is current

**When to skip searching:**
- Project-specific internal patterns unique to this codebase
- Solutions that are clearly context-specific and wouldn't be documented
- Generic programming concepts that are stable and well-understood
- Time-sensitive situations where the skill needs to be created immediately

**Search strategy:**
```
1. Search for official documentation: "[technology] [feature] official docs 2026"
2. Search for best practices: "[technology] [problem] best practices 2026"
3. Search for common issues: "[technology] [error message] solution 2026"
4. Review top results and incorporate relevant information
5. Always cite sources in a "References" section of the skill
```

**Example searches:**
- "Next.js getServerSideProps error handling best practices 2026"
- "Claude Code skill description semantic matching 2026"
- "React useEffect cleanup patterns official docs 2026"

**Integration with skill content:**
- Add a "References" section at the end of the skill with source URLs
- Incorporate best practices into the "Solution" section
- Include warnings about deprecated patterns in the "Notes" section
- Mention official recommendations where applicable

### Step 3: Structure the Skill

Create a new skill with this structure:

```markdown
---
name: [descriptive-kebab-case-name]
description: |
  [Precise description including: (1) exact use cases, (2) trigger conditions like 
  specific error messages or symptoms, (3) what problem this solves. Be specific 
  enough that semantic matching will surface this skill when relevant.]
author: [original-author or "Claude Code"]
version: 1.0.0
date: [YYYY-MM-DD]
---

# [Skill Name]

## Problem
[Clear description of the problem this skill addresses]

## Context / Trigger Conditions  
[When should this skill be used? Include exact error messages, symptoms, or scenarios]

## Solution
[Step-by-step solution or knowledge to apply]

## Verification
[How to verify the solution worked]

## Example
[Concrete example of applying this skill]

## Notes
[Any caveats, edge cases, or related considerations]

## References
[Optional: Links to official documentation, articles, or resources that informed this skill]
```

### Step 4: Write Effective Descriptions

The description field is critical for skill discovery. Include:

- **Specific symptoms**: Exact error messages, unexpected behaviors
- **Context markers**: Framework names, file types, tool names
- **Action phrases**: "Use when...", "Helps with...", "Solves..."

Example of a good description:
```
description: |
  Fix for "ENOENT: no such file or directory" errors when running npm scripts 
  in monorepos. Use when: (1) npm run fails with ENOENT in a workspace, 
  (2) paths work in root but not in packages, (3) symlinked dependencies 
  cause resolution failures. Covers node_modules resolution in Lerna, 
  Turborepo, and npm workspaces.
```

### Step 5: Save the Skill

Save new skills to the appropriate location:

- **Project-specific skills**: `.claude/skills/[skill-name]/SKILL.md`
- **User-wide skills**: `~/.claude/skills/[skill-name]/SKILL.md`

Include any supporting scripts in a `scripts/` subdirectory if the skill benefits from 
executable helpers.

## Retrospective Mode

When `/claudeception` is invoked at the end of a session:

1. **Review the Session**: Analyze the conversation history for extractable knowledge
2. **Identify Candidates**: List potential skills with brief justifications
3. **Prioritize**: Focus on the highest-value, most reusable knowledge
4. **Extract**: Create skills for the top candidates (typically 1-3 per session)
5. **Summarize**: Report what skills were created and why

## Self-Reflection Prompts

Use these prompts during work to identify extraction opportunities:

- "What did I just learn that wasn't obvious before starting?"
- "If I faced this exact problem again, what would I wish I knew?"
- "What error message or symptom led me here, and what was the actual cause?"
- "Is this pattern specific to this project, or would it help in similar projects?"
- "What would I tell a colleague who hits this same issue?"

## Memory Consolidation

When extracting skills, also consider:

1. **Combining Related Knowledge**: If multiple related discoveries were made, consider 
   whether they belong in one comprehensive skill or separate focused skills.

2. **Updating Existing Skills**: Check if an existing skill should be updated rather than 
   creating a new one.

3. **Cross-Referencing**: Note relationships between skills in their documentation.

## Quality Gates

Before finalizing a skill, verify:

- [ ] Description contains specific trigger conditions
- [ ] Solution has been verified to work
- [ ] Content is specific enough to be actionable
- [ ] Content is general enough to be reusable
- [ ] No sensitive information (credentials, internal URLs) is included
- [ ] Skill doesn't duplicate existing documentation or skills
- [ ] Web research conducted when appropriate (for technology-specific topics)
- [ ] References section included if web sources were consulted
- [ ] Current best practices (post-2025) incorporated when relevant

## Anti-Patterns to Avoid

- **Over-extraction**: Not every task deserves a skill. Mundane solutions don't need preservation.
- **Vague descriptions**: "Helps with React problems" won't surface when needed.
- **Unverified solutions**: Only extract what actually worked.
- **Documentation duplication**: Don't recreate official docs; link to them and add what's missing.
- **Stale knowledge**: Mark skills with versions and dates; knowledge can become outdated.

## Skill Lifecycle

Skills should evolve:

1. **Creation**: Initial extraction with documented verification
2. **Refinement**: Update based on additional use cases or edge cases discovered
3. **Deprecation**: Mark as deprecated when underlying tools/patterns change
4. **Archival**: Remove or archive skills that are no longer relevant

## Example: Complete Extraction Flow

**Scenario**: While debugging a Next.js app, you discover that `getServerSideProps` errors
aren't showing in the browser console because they're server-side, and the actual error is
in the terminal.

**Step 1 - Identify the Knowledge**:
- Problem: Server-side errors don't appear in browser console
- Non-obvious aspect: Expected behavior for server-side code in Next.js
- Trigger: Generic error page with empty browser console

**Step 2 - Research Best Practices**:
Search: "Next.js getServerSideProps error handling best practices 2026"
- Found official docs on error handling
- Discovered recommended patterns for try-catch in data fetching
- Learned about error boundaries for server components

**Step 3-5 - Structure and Save**:

**Extraction**:

```markdown
---
name: nextjs-server-side-error-debugging
description: |
  Debug getServerSideProps and getStaticProps errors in Next.js. Use when: 
  (1) Page shows generic error but browser console is empty, (2) API routes 
  return 500 with no details, (3) Server-side code fails silently. Check 
  terminal/server logs instead of browser for actual error messages.
author: Claude Code
version: 1.0.0
date: 2024-01-15
---

# Next.js Server-Side Error Debugging

## Problem
Server-side errors in Next.js don't appear in the browser console, making 
debugging frustrating when you're looking in the wrong place.

## Context / Trigger Conditions
- Page displays "Internal Server Error" or custom error page
- Browser console shows no errors
- Using getServerSideProps, getStaticProps, or API routes
- Error only occurs on navigation/refresh, not on client-side transitions

## Solution
1. Check the terminal where `npm run dev` is running—errors appear there
2. For production, check server logs (Vercel dashboard, CloudWatch, etc.)
3. Add try-catch with console.error in server-side functions for clarity
4. Use Next.js error handling: return `{ notFound: true }` or `{ redirect: {...} }` 
   instead of throwing

## Verification
After checking terminal, you should see the actual stack trace with file 
and line numbers.

## Notes
- This applies to all server-side code in Next.js, not just data fetching
- In development, Next.js sometimes shows a modal with partial error info
- The `next.config.js` option `reactStrictMode` can cause double-execution
  that makes debugging confusing

## References
- [Next.js Data Fetching: getServerSideProps](https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props)
- [Next.js Error Handling](https://nextjs.org/docs/pages/building-your-application/routing/error-handling)
```

## Integration with Workflow

### Automatic Trigger Conditions

Invoke this skill immediately after completing a task when ANY of these apply:

1. **Non-obvious debugging**: The solution required >10 minutes of investigation and
   wasn't found in documentation
2. **Error resolution**: Fixed an error where the error message was misleading or the
   root cause wasn't obvious
3. **Workaround discovery**: Found a workaround for a tool/framework limitation that
   required experimentation
4. **Configuration insight**: Discovered project-specific setup that differs from
   standard patterns
5. **Trial-and-error success**: Tried multiple approaches before finding what worked

### Explicit Invocation

Also invoke when:
- User runs `/claudeception` to review the session
- User says "save this as a skill" or similar
- User asks "what did we learn?"

### Self-Check After Each Task

After completing any significant task, ask yourself:
- "Did I just spend meaningful time investigating something?"
- "Would future-me benefit from having this documented?"
- "Was the solution non-obvious from documentation alone?"

If yes to any, invoke this skill immediately.

Remember: The goal is continuous, autonomous improvement. Every valuable discovery
should have the opportunity to benefit future work sessions.

---

<task-notification>
<task-id>b2279dd</task-id>
<tool-use-id>REDACTED</tool-use-id>
<output-file>/private/tmp/claude-501/-Users-nan-Work-ai-vault/tasks/b2279dd.output</output-file>
<status>completed</status>
<summary>Background command "Deploy to TestFlight with build number bump" completed (exit code 0)</summary>
</task-notification>
Read the output file to retrieve the result: /private/tmp/claude-501/-Users-nan-Work-ai-vault/tasks/b2279dd.output

---

I want to improve the shared vault's experience. Let's expand the area with red rectangle and show:
- if there are limited times the vault can be opened show how many are left
- show if files can be exported
- show the expiration date, if there is one (I know we already show this one)

When done, build a test to verify this

---

[Image: source: /Users/nan/Downloads/Screenshot 2026-02-21 at 11.41.56 PM.png]